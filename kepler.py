# -*- coding: utf-8 -*-
"""Kepler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zBib8AQiIAMHtUDyeKHq3E55okDabFwq
"""

#! pip install

import numpy as np
import matplotlib.pyplot as plt

from numpy import array,arange
# Constants
m = 9.1094e-31     # Mass of electron
hbar = 1.0546e-34  # Planck's constant over 2*pi
e = 1.6022e-19     # Electron charge
L = 5.2918e-11     # Bohr radius
N = 1000
h = L/N

# Potential function
def V(x):
    return 0.0

def f(r,x,E):
    psi = r[0]
    phi = r[1]
    fpsi = phi
    fphi = (2*m/hbar**2)*(V(x)-E)*psi
    return array([fpsi,fphi],float)

# Calculate the wavefunction for a particular energy
def solve(E):
    psi = 0.0
    phi = 1.0
    r = array([psi,phi],float)

    for x in arange(0,L,h):
        k1 = h*f(r,x,E)
        k2 = h*f(r+0.5*k1,x+0.5*h,E)
        k3 = h*f(r+0.5*k2,x+0.5*h,E)
        k4 = h*f(r+k3,x+h,E)
        r += (k1+2*k2+2*k3+k4)/6

    return r[0]

# Main program to find the energy using the secant method
E1 = 0.0
E2 = e
psi2 = solve(E1)

target = e/1000
rr = []
Er = []
while abs(E1-E2)>target:
    psi1,psi2 = psi2,solve(E2)
    rr.append(psi2)
    E1,E2 = E2,E2-psi2*(E2-E1)/(psi2-psi1)
    Er.append(E2)

print("E =",E2/e,"eV")
print(rr)
print(Er)

import numpy
from numpy.lib.arraysetops import ediff1d
#as described within the BornOppenheimer approximation (i.e., with m = me and
#the Coulombic parameter γ = 1 au, so that μ = γ/m = 1 au)
au = 1.49597870e11 #1 au in m
gamma = 1*au
m = 1*au
mu = 1*au
Es = np.array(Er)/e
print(Es)



#Circular Motion r0v0 = 0, the eccentricity e = 0Motion. When r0 3 v0 = 0, the eccentricity e = 0

j = np.sqrt(2*abs(Es)/m)
n = j**3/mu
cr = np.cos(n)
cv = np.sin(n)
#suppose r0 = 0, X = 0 the position of the singularity
r0 = 0.1
v0 = np.sqrt(mu/r0)
rt = cr*r0 + cv*v0/n
v = -n*cv*r0 + cr*v0
print(rt)
x = np.linspace(-rt[0],rt[0],100)
y1 = np.sqrt(rt[0]**2-x**2)
y2 = -y1
plt.plot(x,y1)
plt.plot(x,y2)

#Parabolic Motion
B = np.dot(L,e)
tau0 = r0*v0/mu
p = L**2/mu
tp = -tau0*(p+mu*tau0**2/3)
#t in as
t = np.linspace(0,50,100)
tD = 3*(t-tp)
D = tD**2 + p**3/mu
tau = ((tD+np.sqrt(D))**1/3+(tD-np.sqrt(D))**1/3)
r = 0.5*(p+mu*(tau)**2)
plt.plot(r,tau)

print(r)

#initial
x = np.linspace(-r[0],r[0],100)
y1 = np.sqrt(r**2-x**2)
y2 = -y1
plt.plot(x,y1)
plt.plot(x,y2)

#final
x = np.linspace(-r[99],r[99],100)
y1 = np.sqrt(r**2-x**2)
y2 = -y1
plt.plot(x,y1)
plt.plot(x,y2)

#Elliptic and Hyperbolic Motion
k = -2*h/mu
j = np.sqrt(2*abs(h))
r = 0.5*()