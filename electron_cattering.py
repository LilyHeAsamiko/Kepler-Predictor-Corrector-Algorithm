# -*- coding: utf-8 -*-
"""Electron cattering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DSSrhLXbzFpPsTb-Yx7HcHd4qsW34hEu
"""

#Electron Cattering

import numpy as np
import matplotlib.pyplot as plt

from numpy import array,arange
# Constants
m = 9.1094e-31     # Mass of electron
hbar = 1.0546e-34  # Planck's constant over 2*pi
e = 1.6022e-19     # Electron charge
L = 5.2918e-11     # Bohr radius
N = 1000
h = L/N

# Potential function
def V(x):
    return 0.0

def f(r,x,E):
    psi = r[0]
    phi = r[1]
    fpsi = phi
    fphi = (2*m/hbar**2)*(V(x)-E)*psi
    return array([fpsi,fphi],float)

# Calculate the wavefunction for a particular energy
def solve(E):
    psi = 0.0
    phi = 1.0
    r = array([psi,phi],float)

    for x in arange(0,L,h):
        k1 = h*f(r,x,E)
        k2 = h*f(r+0.5*k1,x+0.5*h,E)
        k3 = h*f(r+0.5*k2,x+0.5*h,E)
        k4 = h*f(r+k3,x+h,E)
        r += (k1+2*k2+2*k3+k4)/6

    return r[0]

# Main program to find the energy using the secant method
E1 = 0.0
E2 = e
psi2 = solve(E1)

target = e/1000
rr = []
Er = []
while abs(E1-E2)>target:
    psi1,psi2 = psi2,solve(E2)
    rr.append(psi2)
    E1,E2 = E2,E2-psi2*(E2-E1)/(psi2-psi1)
    Er.append(E2)

print("E =",E2/e,"eV")
print(rr)
print(Er)

au = 1.49597870e11 #1 au in m

#over all proton j(assume j = 3)
x = np.linspace(-0.5,0.5,50)
dx = 0.1
for i in [1,2,3]:
  R1 = -4
  x0 = -5
  x += dx
  V = -e/abs(x-R1) #eV
  k = rr
  print(k)
  s1 = (1*au)**2+(k[-1]*0.2*au)**2
  r0 = (s1)**(1/2)
  E = 9.2 #eV
  p0 = np.sqrt(2*m*(E+1/r0))
  sigma = 0.5
  sigmax = sigma
  sigmap = hbar/2/sigmax
  p = p0 + np.sqrt(np.std(-(x-x0)**2/2/sigmax**2))/np.size(x)
  P0 = 1/(2*np.pi*hbar*sigmax*sigmap)**3*np.exp(-(x-x0)**2/2/sigmax**2-1/((p-p0)**2/2/sigmap**2))
  print(p0)
  print(p)
  print((2*np.pi*hbar*sigmax*sigmap)**3)
  print(-(x-x0)**2/2/sigmax**2)
  print(-1/((p-p0)**2/2/sigmap**2))
  print(P0)
  plt.plot(range(10),-P0[range(10)])

